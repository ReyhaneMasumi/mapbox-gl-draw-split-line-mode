{"version":3,"sources":["../../node_modules/geojson-rbush/quickselect.js","../../node_modules/geojson-rbush/rbush.js","../../node_modules/@turf/helpers/main.es.js","../../node_modules/@turf/meta/main.es.js","../../node_modules/geojson-rbush/index.js","../../node_modules/@turf/invariant/main.es.js","../../node_modules/@turf/distance/main.es.js","../../node_modules/@turf/line-segment/main.es.js","../../node_modules/@turf/line-intersect/main.es.js","../../node_modules/@turf/bearing/main.es.js","../../node_modules/@turf/destination/main.es.js","../../node_modules/@turf/line-split/main.es.js","../../node_modules/@turf/bbox/main.es.js","../../node_modules/@turf/square/main.es.js","../../node_modules/@turf/nearest-point-on-line/main.es.js","../../src/index.js","../../node_modules/@turf/truncate/main.es.js","App.js","reportWebVitals.js","index.js"],"names":["quickselect","arr","k","left","right","compare","quickselectStep","length","defaultCompare","n","m","z","Math","log","s","exp","sd","sqrt","max","floor","min","t","i","j","swap","tmp","a","b","rbush","maxEntries","format","this","_maxEntries","_minEntries","ceil","_initFormat","clear","findItem","item","items","equalsFn","indexOf","calcBBox","node","toBBox","distBBox","children","p","destNode","createNode","minX","Infinity","minY","maxX","maxY","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains","intersects","height","multiSelect","mid","stack","pop","push","prototype","all","_all","data","search","bbox","result","len","childBBox","nodesToSearch","collides","load","insert","_build","slice","_splitRoot","tmpNode","_insert","remove","parent","index","goingUp","path","indexes","splice","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","N","M","pow","right2","right3","N2","N1","_chooseSubtree","level","targetNode","area","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","compareArr","Function","join","factors","meters","metres","millimeters","earthRadius","millimetres","centimeters","centimetres","kilometers","kilometres","miles","nauticalmiles","inches","yards","feet","radians","degrees","feature","geometry","properties","options","isObject","Error","id","constructor","Object","validateBBox","validateId","feat","type","point","coordinates","Array","isArray","isNumber","lineString","featureCollection","features","fc","radiansToDegrees","PI","degreesToRadians","num","isNaN","input","forEach","coordEach","geojson","callback","excludeWrapCoord","l","stopG","coords","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","geomType","featureEach","flattenEach","g","featureProperties","featureBBox","featureId","coordinate","geojsonRbush","tree","bboxPolygon","turfBBox","call","json","lowLeft","topLeft","topRight","coord","getCoord","obj","getCoords","containsNumber","getType","name","distance","from","to","units","coordinates1","coordinates2","dLat","dLon","lat1","lat2","sin","cos","factor","atan2","lineSegment","results","segments","reduce","previousCoords","currentCoords","coords1","coords2","x1","y1","x2","y2","segment","lineIntersect","line1","line2","unique","intersect","match","key","x3","y3","x4","y4","denom","uA","uB","bearing","start","end","final","bear","lon1","lon2","destination","origin","longitude1","latitude1","bearing_rad","latitude2","asin","splitLineWithPoints","line","splitter","closestLine","findClosestFeature","filter","splitLineWithPoint","BBox","west","south","east","north","verticalMidpoint","horizontalMidpoint","startPoint","endPoint","pointsEquals","closestSegment","lastCoords","initialValue","previousValue","currentFeature","previous","current","splitterCoords","lines","closestFeature","closestDistance","dist","pt","closestPt","sectionLength","heightDistance","direction","perpendicularPt1","perpendicularPt2","lineIntersects","intersectPt","location","nearestPointOnLine","pt1","pt2","SplitLineMode","onSetup","spliter","main","getSelected","map","f","toGeoJSON","toDisplayFeatures","state","display","changeMode","cut","idx","geojsonTypes","LINE_STRING","MULTI_LINE_STRING","afterCut","lineType","splitterType","truncatedSplitter","precision","mutate","JSON","parse","stringify","round","truncate","el","newF","newFeature","addFeature","deleteFeature","silent","onKeyUp","e","keyCode","exitMode","modes","SIMPLE_SELECT","draw","drawBar","extendDrawBar","opt","ctrl","buttons","onAddOrig","onAdd","onRemoveOrig","onRemove","elContainer","addButton","removeButton","elButton","document","createElement","className","classes","c","classList","add","addEventListener","on","action","appendChild","removeEventListener","App","useState","isActive","setIsActive","mapRef","useRef","openMenu","mapboxGl","getRTLTextPluginStatus","setRTLTextPlugin","err","console","error","useEffect","Map","container","style","center","zoom","pitch","interactive","hash","attributionControl","customAttribution","transformRequest","url","headers","MapboxDraw","splitLineMode","passing_mode_point","mapboxGlDrawPassingMode","draw_point","passing_mode_line_string","draw_line_string","passing_mode_polygon","draw_polygon","userProperties","once","resize","addControl","set","splitLine","mode","alert","message","ref","onClick","reportWebVitals","onPerfEntry","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.1413f682.chunk.js","sourcesContent":["function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nexport default quickselect;\n","import quickselect from './quickselect';\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nexport default rbush;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { feature, lineString } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                callback(null, featureIndex, featureProperties, featureBBox, featureId);\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                callback(geometry, featureIndex, featureProperties, featureBBox, featureId);\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId);\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0);\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        geometry.coordinates.forEach(function (coordinate, multiFeatureIndex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), featureIndex, multiFeatureIndex);\n        });\n\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        coordReduce(feature$$1, function (previousCoords, currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n            segmentIndex++;\n            return currentCoord;\n        });\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0);\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex);\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce };\n","import rbush from './rbush';\nimport {featureEach, coordEach} from '@turf/meta';\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * import geojsonRbush from 'geojson-rbush';\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature<any>} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.insert(polygon)\n     */\n    tree.insert = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        } else {\n            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        }\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {BBox[]|FeatureCollection<any>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygons = {\n     *   \"type\": \"FeatureCollection\",\n     *   \"features\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *       }\n     *     },\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     *       }\n     *     }\n     *   ]\n     * }\n     * tree.load(polygons)\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of BBox\n        if (Array.isArray(features)) {\n            features.forEach(function (bbox) {\n                var feature = bboxPolygon(bbox);\n                feature.bbox = bbox;\n                load.push(feature);\n            });\n        } else {\n            // Load FeatureCollection\n            featureEach(features, function (feature) {\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {BBox|Feature<any>} feature remove single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.remove(polygon)\n     */\n    tree.remove = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        }\n        return rbush.prototype.remove.call(this, feature);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson search with GeoJSON\n     * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.search(polygon)\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.collides(polygon)\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection<any>} all the features in RBush\n     * @example\n     * tree.all()\n     * //=FeatureCollection\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     * //=JSON object\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else bbox = turfBBox(geojson);\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @private\n * @name bboxPolygon\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nfunction bboxPolygon(bbox) {\n    var lowLeft = [bbox[0], bbox[1]];\n    var topLeft = [bbox[0], bbox[3]];\n    var topRight = [bbox[2], bbox[3]];\n    var lowRight = [bbox[2], bbox[1]];\n    var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];\n\n    return {\n        type: 'Feature',\n        bbox: bbox,\n        properties: {},\n        geometry: {\n            type: 'Polygon',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @private\n * @name bbox\n * @param {FeatureCollection|Feature<any>} geojson input features\n * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction turfBBox(geojson) {\n    var bbox = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (bbox[0] > coord[0]) bbox[0] = coord[0];\n        if (bbox[1] > coord[1]) bbox[1] = coord[1];\n        if (bbox[2] < coord[0]) bbox[2] = coord[0];\n        if (bbox[3] < coord[1]) bbox[3] = coord[1];\n    });\n    return bbox;\n}\n\nexport default geojsonRbush;\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToLength } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n}\n\nexport default distance;\n","import { featureCollection, lineString } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport { flattenEach } from '@turf/meta';\n\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|MultiPolygon|Polygon>} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    switch (geometry.type) {\n    case 'Polygon':\n        coords = getCoords(geometry);\n        break;\n    case 'LineString':\n        coords = [getCoords(geometry)];\n    }\n    coords.forEach(function (coord) {\n        var segments = createSegments(coord, geojson.properties);\n        segments.forEach(function (segment) {\n            segment.id = results.length;\n            results.push(segment);\n        });\n    });\n}\n\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {LineString} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = (x1 < x2) ? x1 : x2;\n    var south = (y1 < y2) ? y1 : y2;\n    var east = (x1 > x2) ? x1 : x2;\n    var north = (y1 > y2) ? y1 : y2;\n    return [west, south, east, north];\n}\n\nexport default lineSegment;\n","import rbush from 'geojson-rbush';\nimport lineSegment from '@turf/line-segment';\nimport { getCoords } from '@turf/invariant';\nimport { featureEach } from '@turf/meta';\nimport { feature, featureCollection, point } from '@turf/helpers';\n\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === 'LineString') line1 = feature(line1);\n    if (line2.type === 'LineString') line2 = feature(line2);\n    if (line1.type === 'Feature' &&\n        line2.type === 'Feature' &&\n        line1.geometry.type === 'LineString' &&\n        line2.geometry.type === 'LineString' &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) results.push(intersect);\n        return featureCollection(results);\n    }\n\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(',');\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error('<intersects> line1 must only contain 2 coordinates');\n    }\n    if (coords2.length !== 2) {\n        throw new Error('<intersects> line2 must only contain 2 coordinates');\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + (uA * (x2 - x1));\n        var y = y1 + (uA * (y2 - y1));\n        return point([x, y]);\n    }\n    return null;\n}\n\nexport default lineIntersect;\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToDegrees } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var final = options.final;\n\n    // Reverse calculation\n    if (final === true) return calculateFinalBearing(start, end);\n\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    return radiansToDegrees(Math.atan2(a, b));\n}\n\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n\nexport default bearing;\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, lengthToRadians, point, radiansToDegrees } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n    var properties = options.properties;\n\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearing_rad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, units);\n\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1),\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n\n    return point([lng, lat], properties);\n}\n\nexport default destination;\n","import rbush from 'geojson-rbush';\nimport square from '@turf/square';\nimport bbox from '@turf/bbox';\nimport truncate from '@turf/truncate';\nimport lineSegment from '@turf/line-segment';\nimport lineIntersect from '@turf/line-intersect';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { getCoord, getCoords, getType } from '@turf/invariant';\nimport { featureEach, featureReduce, flattenEach } from '@turf/meta';\nimport { featureCollection, lineString } from '@turf/helpers';\n\n/**\n * Split a LineString by another GeoJSON Feature.\n *\n * @name lineSplit\n * @param {Feature<LineString>} line LineString Feature to split\n * @param {Feature<any>} splitter Feature used to split line\n * @returns {FeatureCollection<LineString>} Split LineStrings\n * @example\n * var line = turf.lineString([[120, -25], [145, -25]]);\n * var splitter = turf.lineString([[130, -15], [130, -35]]);\n *\n * var split = turf.lineSplit(line, splitter);\n *\n * //addToMap\n * var addToMap = [line, splitter]\n */\nfunction lineSplit(line, splitter) {\n    if (!line) throw new Error('line is required');\n    if (!splitter) throw new Error('splitter is required');\n\n    var lineType = getType(line);\n    var splitterType = getType(splitter);\n\n    if (lineType !== 'LineString') throw new Error('line must be LineString');\n    if (splitterType === 'FeatureCollection') throw new Error('splitter cannot be a FeatureCollection');\n    if (splitterType === 'GeometryCollection') throw new Error('splitter cannot be a GeometryCollection');\n\n    // remove excessive decimals from splitter\n    // to avoid possible approximation issues in rbush\n    var truncatedSplitter = truncate(splitter, {precision: 7});\n\n    switch (splitterType) {\n    case 'Point':\n        return splitLineWithPoint(line, truncatedSplitter);\n    case 'MultiPoint':\n        return splitLineWithPoints(line, truncatedSplitter);\n    case 'LineString':\n    case 'MultiLineString':\n    case 'Polygon':\n    case 'MultiPolygon':\n        return splitLineWithPoints(line, lineIntersect(line, truncatedSplitter));\n    }\n}\n\n/**\n * Split LineString with MultiPoint\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {FeatureCollection<Point>} splitter Point\n * @returns {FeatureCollection<LineString>} split LineStrings\n */\nfunction splitLineWithPoints(line, splitter) {\n    var results = [];\n    var tree = rbush();\n\n    flattenEach(splitter, function (point) {\n        // Add index/id to features (needed for filter)\n        results.forEach(function (feature, index) {\n            feature.id = index;\n        });\n        // First Point - doesn't need to handle any previous line results\n        if (!results.length) {\n            results = splitLineWithPoint(line, point).features;\n\n            // Add Square BBox to each feature for GeoJSON-RBush\n            results.forEach(function (feature) {\n                if (!feature.bbox) feature.bbox = square(bbox(feature));\n            });\n            tree.load(featureCollection(results));\n        // Split with remaining points - lines might needed to be split multiple times\n        } else {\n            // Find all lines that are within the splitter's bbox\n            var search = tree.search(point);\n\n            if (search.features.length) {\n                // RBush might return multiple lines - only process the closest line to splitter\n                var closestLine = findClosestFeature(point, search);\n\n                // Remove closest line from results since this will be split into two lines\n                // This removes any duplicates inside the results & index\n                results = results.filter(function (feature) { return feature.id !== closestLine.id; });\n                tree.remove(closestLine);\n\n                // Append the two newly split lines into the results\n                featureEach(splitLineWithPoint(closestLine, point), function (line) {\n                    results.push(line);\n                    tree.insert(line);\n                });\n            }\n        }\n    });\n    return featureCollection(results);\n}\n\n/**\n * Split LineString with Point\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<Point>} splitter Point\n * @returns {FeatureCollection<LineString>} split LineStrings\n */\nfunction splitLineWithPoint(line, splitter) {\n    var results = [];\n\n    // handle endpoints\n    var startPoint = getCoords(line)[0];\n    var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];\n    if (pointsEquals(startPoint, getCoord(splitter)) ||\n        pointsEquals(endPoint, getCoord(splitter))) return featureCollection([line]);\n\n    // Create spatial index\n    var tree = rbush();\n    var segments = lineSegment(line);\n    tree.load(segments);\n\n    // Find all segments that are within bbox of splitter\n    var search = tree.search(splitter);\n\n    // Return itself if point is not within spatial index\n    if (!search.features.length) return featureCollection([line]);\n\n    // RBush might return multiple lines - only process the closest line to splitter\n    var closestSegment = findClosestFeature(splitter, search);\n\n    // Initial value is the first point of the first segments (beginning of line)\n    var initialValue = [startPoint];\n    var lastCoords = featureReduce(segments, function (previous, current, index) {\n        var currentCoords = getCoords(current)[1];\n        var splitterCoords = getCoord(splitter);\n\n        // Location where segment intersects with line\n        if (index === closestSegment.id) {\n            previous.push(splitterCoords);\n            results.push(lineString(previous));\n            // Don't duplicate splitter coordinate (Issue #688)\n            if (pointsEquals(splitterCoords, currentCoords)) return [splitterCoords];\n            return [splitterCoords, currentCoords];\n\n        // Keep iterating over coords until finished or intersection is found\n        } else {\n            previous.push(currentCoords);\n            return previous;\n        }\n    }, initialValue);\n    // Append last line to final split results\n    if (lastCoords.length > 1) {\n        results.push(lineString(lastCoords));\n    }\n    return featureCollection(results);\n}\n\n\n/**\n * Find Closest Feature\n *\n * @private\n * @param {Feature<Point>} point Feature must be closest to this point\n * @param {FeatureCollection<LineString>} lines Collection of Features\n * @returns {Feature<LineString>} closest LineString\n */\nfunction findClosestFeature(point, lines) {\n    if (!lines.features.length) throw new Error('lines must contain features');\n    // Filter to one segment that is the closest to the line\n    if (lines.features.length === 1) return lines.features[0];\n\n    var closestFeature;\n    var closestDistance = Infinity;\n    featureEach(lines, function (segment) {\n        var pt = nearestPointOnLine(segment, point);\n        var dist = pt.properties.dist;\n        if (dist < closestDistance) {\n            closestFeature = segment;\n            closestDistance = dist;\n        }\n    });\n    return closestFeature;\n}\n\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Array<number>} pt1 point\n * @param {Array<number>} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction pointsEquals(pt1, pt2) {\n    return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n\nexport default lineSplit;\n","import { coordEach } from '@turf/meta';\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var BBox = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (BBox[0] > coord[0]) BBox[0] = coord[0];\n        if (BBox[1] > coord[1]) BBox[1] = coord[1];\n        if (BBox[2] < coord[0]) BBox[2] = coord[0];\n        if (BBox[3] < coord[1]) BBox[3] = coord[1];\n    });\n    return BBox;\n}\n\nexport default bbox;\n","import distance from '@turf/distance';\n\n/**\n * Takes a bounding box and calculates the minimum square bounding box that\n * would contain the input.\n *\n * @name square\n * @param {BBox} bbox extent in [west, south, east, north] order\n * @returns {BBox} a square surrounding `bbox`\n * @example\n * var bbox = [-20, -20, -15, 0];\n * var squared = turf.square(bbox);\n *\n * //addToMap\n * var addToMap = [turf.bboxPolygon(bbox), turf.bboxPolygon(squared)]\n */\nfunction square(bbox) {\n    var west = bbox[0];\n    var south = bbox[1];\n    var east = bbox[2];\n    var north = bbox[3];\n\n    var horizontalDistance = distance(bbox.slice(0, 2), [east, south]);\n    var verticalDistance = distance(bbox.slice(0, 2), [west, north]);\n    if (horizontalDistance >= verticalDistance) {\n        var verticalMidpoint = (south + north) / 2;\n        return [\n            west,\n            verticalMidpoint - ((east - west) / 2),\n            east,\n            verticalMidpoint + ((east - west) / 2)\n        ];\n    } else {\n        var horizontalMidpoint = (west + east) / 2;\n        return [\n            horizontalMidpoint - ((north - south) / 2),\n            south,\n            horizontalMidpoint + ((north - south) / 2),\n            north\n        ];\n    }\n}\n\nexport default square;\n","import bearing from '@turf/bearing';\nimport distance from '@turf/distance';\nimport destination from '@turf/destination';\nimport lineIntersects from '@turf/line-intersect';\nimport { flattenEach } from '@turf/meta';\nimport { isObject, lineString, point } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\n\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine(lines, pt, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n\n    // validation\n    var type = (lines.geometry) ? lines.geometry.type : lines.type;\n    if (type !== 'LineString' && type !== 'MultiLineString') {\n        throw new Error('lines must be LineString or MultiLineString');\n    }\n\n    var closestPt = point([Infinity, Infinity], {\n        dist: Infinity\n    });\n\n    var length = 0.0;\n    flattenEach(lines, function (line) {\n        var coords = getCoords(line);\n\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = point(coords[i]);\n            start.properties.dist = distance(pt, start, options);\n            //stop\n            var stop = point(coords[i + 1]);\n            stop.properties.dist = distance(pt, stop, options);\n            // sectionLength\n            var sectionLength = distance(start, stop, options);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n            var direction = bearing(start, stop);\n            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n            var intersect = lineIntersects(\n                lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]),\n                lineString([start.geometry.coordinates, stop.geometry.coordinates])\n            );\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance(pt, intersectPt, options);\n                intersectPt.properties.location = length + distance(start, intersectPt, options);\n            }\n\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop.properties.dist < closestPt.properties.dist) {\n                closestPt = stop;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n\n    });\n\n    return closestPt;\n}\n\nexport default nearestPointOnLine;\n","import { geojsonTypes, modes } from '@mapbox/mapbox-gl-draw/src/constants';\nimport lineSplit from '@turf/line-split';\n\nconst SplitLineMode = {\n  onSetup: function ({ spliter }) {\n    let main = this.getSelected().map((f) => f.toGeoJSON());\n    if (main.length < 1)\n      throw new Error('Please select a Linestring/MultiLinestring!');\n    const state = {\n      main,\n      spliter: `passing_mode_${spliter}`,\n    };\n    return state;\n  },\n\n  toDisplayFeatures: function (state, geojson, display) {\n    display(geojson);\n    this.changeMode(state.spliter, (cut) => {\n      state.main.forEach((feature, idx) => {\n        if (\n          feature.geometry.type === geojsonTypes.LINE_STRING ||\n          feature.geometry.type === geojsonTypes.MULTI_LINE_STRING\n        ) {\n          let afterCut = lineSplit(feature, cut);\n          if (afterCut.features.length < 1) return;\n          afterCut.features.forEach((el) => {\n            let newF = this.newFeature(el);\n            this.addFeature(newF);\n          });\n          this.deleteFeature([feature.id], { silent: true });\n        } else {\n          throw new Error('The feature is not Linestring/MultiLinestring!');\n        }\n      });\n    });\n  },\n\n  onKeyUp: function (state, e) {\n    if (e.keyCode === 27) return this.exitMode();\n  },\n\n  exitMode: function (state, e) {\n    return this.changeMode(modes.SIMPLE_SELECT);\n  },\n};\n\nexport default SplitLineMode;\n","import { coordEach } from '@turf/meta';\nimport { isObject } from '@turf/helpers';\n\n/**\n * Takes a GeoJSON Feature or FeatureCollection and truncates the precision of the geometry.\n *\n * @name truncate\n * @param {GeoJSON} geojson any GeoJSON Feature, FeatureCollection, Geometry or GeometryCollection.\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.precision=6] coordinate decimal precision\n * @param {number} [options.coordinates=3] maximum number of coordinates (primarly used to remove z coordinates)\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} layer with truncated geometry\n * @example\n * var point = turf.point([\n *     70.46923055566859,\n *     58.11088890802906,\n *     1508\n * ]);\n * var options = {precision: 3, coordinates: 2};\n * var truncated = turf.truncate(point, options);\n * //=truncated.geometry.coordinates => [70.469, 58.111]\n *\n * //addToMap\n * var addToMap = [truncated];\n */\nfunction truncate(geojson, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var precision = options.precision;\n    var coordinates = options.coordinates;\n    var mutate = options.mutate;\n\n    // default params\n    precision = (precision === undefined || precision === null || isNaN(precision)) ? 6 : precision;\n    coordinates = (coordinates === undefined || coordinates === null || isNaN(coordinates)) ? 3 : coordinates;\n\n    // validation\n    if (!geojson) throw new Error('<geojson> is required');\n    if (typeof precision !== 'number') throw new Error('<precision> must be a number');\n    if (typeof coordinates !== 'number') throw new Error('<coordinates> must be a number');\n\n    // prevent input mutation\n    if (mutate === false || mutate === undefined) geojson = JSON.parse(JSON.stringify(geojson));\n\n    var factor = Math.pow(10, precision);\n\n    // Truncate Coordinates\n    coordEach(geojson, function (coords) {\n        truncateCoords(coords, factor, coordinates);\n    });\n    return geojson;\n}\n\n/**\n * Truncate Coordinates - Mutates coordinates in place\n *\n * @private\n * @param {Array<any>} coords Geometry Coordinates\n * @param {number} factor rounding factor for coordinate decimal precision\n * @param {number} coordinates maximum number of coordinates (primarly used to remove z coordinates)\n * @returns {Array<any>} mutated coordinates\n */\nfunction truncateCoords(coords, factor, coordinates) {\n    // Remove extra coordinates (usually elevation coordinates and more)\n    if (coords.length > coordinates) coords.splice(coordinates, coords.length);\n\n    // Truncate coordinate decimals\n    for (var i = 0; i < coords.length; i++) {\n        coords[i] = Math.round(coords[i] * factor) / factor;\n    }\n    return coords;\n}\n\nexport default truncate;\n","import React, { useState, useRef, useEffect } from 'react';\nimport mapboxGl from 'mapbox-gl';\nimport MapboxDraw from '@mapbox/mapbox-gl-draw';\nimport '@mapbox/mapbox-gl-draw/dist/mapbox-gl-draw.css';\nimport SplitLineMode from 'mapbox-gl-draw-split-line-mode';\nimport mapboxGlDrawPassingMode from 'mapbox-gl-draw-passing-mode';\nimport './App.css';\n\nlet map;\nlet draw;\nlet drawBar;\n\nclass extendDrawBar {\n  constructor(opt) {\n    let ctrl = this;\n    ctrl.draw = opt.draw;\n    ctrl.buttons = opt.buttons || [];\n    ctrl.onAddOrig = opt.draw.onAdd;\n    ctrl.onRemoveOrig = opt.draw.onRemove;\n  }\n  onAdd(map) {\n    let ctrl = this;\n    ctrl.map = map;\n    ctrl.elContainer = ctrl.onAddOrig(map);\n    ctrl.buttons.forEach((b) => {\n      ctrl.addButton(b);\n    });\n    return ctrl.elContainer;\n  }\n  onRemove(map) {\n    let ctrl = this;\n    ctrl.buttons.forEach((b) => {\n      ctrl.removeButton(b);\n    });\n    ctrl.onRemoveOrig(map);\n  }\n  addButton(opt) {\n    let ctrl = this;\n    var elButton = document.createElement('button');\n    elButton.className = 'mapbox-gl-draw_ctrl-draw-btn';\n    if (opt.classes instanceof Array) {\n      opt.classes.forEach((c) => {\n        elButton.classList.add(c);\n      });\n    }\n    elButton.addEventListener(opt.on, opt.action);\n    ctrl.elContainer.appendChild(elButton);\n    opt.elButton = elButton;\n  }\n  removeButton(opt) {\n    opt.elButton.removeEventListener(opt.on, opt.action);\n    opt.elButton.remove();\n  }\n}\n\nfunction App() {\n  const [isActive, setIsActive] = useState(false);\n  let mapRef = useRef(null);\n\n  const openMenu = () => {\n    setIsActive(true);\n  };\n\n  if (mapboxGl.getRTLTextPluginStatus() === 'unavailable')\n    mapboxGl.setRTLTextPlugin(\n      'https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js',\n      (err) => {\n        err && console.error(err);\n      },\n      true\n    );\n\n  useEffect(() => {\n    map = new mapboxGl.Map({\n      container: mapRef.current || '',\n      style: `https://map.ir/vector/styles/main/mapir-xyz-light-style.json`,\n      center: [51.3857, 35.6102],\n      zoom: 10,\n      pitch: 0,\n      interactive: true,\n      hash: true,\n      attributionControl: true,\n      customAttribution: ' Map  Openstreetmap',\n      transformRequest: (url) => {\n        return {\n          url: url,\n          headers: {\n            'x-api-key':\n              'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6ImRiZWU0YWU4OTk4OTA3MmQ3OTFmMjQ4ZDE5N2VhZTgwZWU2NTUyYjhlYjczOWI2NDdlY2YyYzIzNWRiYThiMzIzOTM5MDkzZDM0NTY2MmU3In0.eyJhdWQiOiI5NDMyIiwianRpIjoiZGJlZTRhZTg5OTg5MDcyZDc5MWYyNDhkMTk3ZWFlODBlZTY1NTJiOGViNzM5YjY0N2VjZjJjMjM1ZGJhOGIzMjM5MzkwOTNkMzQ1NjYyZTciLCJpYXQiOjE1OTA4MjU0NzIsIm5iZiI6MTU5MDgyNTQ3MiwiZXhwIjoxNTkzNDE3NDcyLCJzdWIiOiIiLCJzY29wZXMiOlsiYmFzaWMiXX0.M_z4xJlJRuYrh8RFe9UrW89Y_XBzpPth4yk3hlT-goBm8o3x8DGCrSqgskFfmJTUD2wC2qSoVZzQKB67sm-swtD5fkxZO7C0lBCMAU92IYZwCdYehIOtZbP5L1Lfg3C6pxd0r7gQOdzcAZj9TStnKBQPK3jSvzkiHIQhb6I0sViOS_8JceSNs9ZlVelQ3gs77xM2ksWDM6vmqIndzsS-5hUd-9qdRDTLHnhdbS4_UBwNDza47Iqd5vZkBgmQ_oDZ7dVyBuMHiQFg28V6zhtsf3fijP0UhePCj4GM89g3tzYBOmuapVBobbX395FWpnNC3bYg7zDaVHcllSUYDjGc1A', //dev api key\n            'Mapir-SDK': 'reactjs',\n          },\n        };\n      },\n    });\n    draw = new MapboxDraw({\n      modes: {\n        ...MapboxDraw.modes,\n        splitLineMode: SplitLineMode,\n        passing_mode_point: mapboxGlDrawPassingMode(\n          MapboxDraw.modes.draw_point\n        ),\n        passing_mode_line_string: mapboxGlDrawPassingMode(\n          MapboxDraw.modes.draw_line_string\n        ),\n        passing_mode_polygon: mapboxGlDrawPassingMode(\n          MapboxDraw.modes.draw_polygon\n        ),\n      },\n      userProperties: true,\n    });\n    drawBar = new extendDrawBar({\n      draw: draw,\n      buttons: [\n        {\n          on: 'click',\n          action: openMenu,\n          classes: ['split-icon'],\n        },\n      ],\n    });\n    map.once('load', () => {\n      map.resize();\n      map.addControl(drawBar, 'top-right');\n      draw.set({\n        type: 'FeatureCollection',\n        features: [\n          {\n            id: 'example_id',\n            type: 'Feature',\n            properties: {},\n            geometry: {\n              type: 'LineString',\n              coordinates: [\n                [51.46717071533203, 35.752642192392955],\n                [51.41704559326172, 35.7715862712587],\n                [51.37207031249999, 35.73954585450408],\n                [51.31988525390625, 35.753756674845675],\n                [51.29344940185547, 35.713904233681035],\n                [51.37035369873047, 35.67012719291238],\n                [51.32434844970703, 35.633581468816594],\n              ],\n            },\n          },\n        ],\n      });\n    });\n  }, []);\n\n  const splitLine = (mode) => {\n    try {\n      draw?.changeMode('splitLineMode', { spliter: mode });\n    } catch (err) {\n      alert(err.message);\n      console.error(err);\n    }\n  };\n\n  return (\n    <div className=\"map-wrapper\">\n      <div id=\"map\" ref={mapRef} />\n      {isActive ? (\n        <div className={`mapboxgl-ctrl-group mapboxgl-ctrl split`}>\n          <button\n            className=\"mapbox-gl-draw_ctrl-draw-btn mapbox-gl-draw_line\"\n            onClick={() => {\n              splitLine('line_string');\n              setIsActive(false);\n            }}\n          />\n          <button\n            className=\"mapbox-gl-draw_ctrl-draw-btn mapbox-gl-draw_point\"\n            onClick={() => {\n              splitLine('point');\n              setIsActive(false);\n            }}\n          />\n          <button\n            className=\"mapbox-gl-draw_ctrl-draw-btn mapbox-gl-draw_polygon\"\n            onClick={() => {\n              splitLine('polygon');\n              setIsActive(false);\n            }}\n          />\n        </div>\n      ) : null}\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}